---
layout: post
title: "Mathematica Programming-An Advanced Introduction"
date: 2014-08-19 17:57:53 -0400
comments: true
categories: [mathematica, CN]
published: false
---


# Mathematica 编程：高级导论
本书的英文版 [Mathematica programming: an advanced introduction](http://www.mathprogramming-intro.org/), by Leonid Shifrin
<!--more-->
* list element with functor item
{:toc}


## 序言

## 简介

## 基本操作

## 表

## 规则, 模式和函数

## 表处理函数与函数式编程

### 介绍
所谓的"函数式编程", 是这样一种编程范式: 扮演核心角色的, 是函数对数据或者其他函数的作用. 函数本身也被当作是数据的一种, 从而可以作为其他函数的额参被使用. 考虑到任意的数据结构都可以利用`表`来构造, 所以函数式编程的主要内容就是关于函数对`表`的作用.

`Mathematica` 中的函数式编程, 和其他的一些语言(比如 lisp) 中的函数式编程有一些显著的区别. 比如说, `表`的递归表示, 在`Mathematica` 中并如其他函数式语言中的表那么高效, 因为本质上, `Mathematica` 的`表`是用链表来实现的. 另一个重要的区别, 则是由`Mathematica`的`规则`导致的, 要看到这一点, 请读者回忆,`Mathematica` 中的函数定义实际上是基于模式匹配规则替换的, 而计算过程本身由是全局`规则库`所控制的表达式重写的过程.

除了简约紧凑,函数式编程的风格同常还是在`Mathematica`中最高效的表达方式. 此外, 尽管我们不会在本章论及, 但还是值得在这里让读者知道, 函数式的技巧不仅可以作用到`表`上,还可以作用到一般的表达式中. 随着理解的深入, 读者将会看到这是一个强有力的语言特性.

简单地说一下本章所扮演的角色. 毫不夸张地说, 本章是本书所有章节中最核心的一章, 这是因为, 本章介绍了新的编程风格和信条, 而这种风格和信条不单单在我们此后的内容里反复出现,它实际上帮助将你的`Mathematica`编程水平提升到一个新的档次 -- 不仅仅是技巧上的, 而是改变整个思考问题的方式. 那些原本就熟悉函数式编程的读者, 会发现本章的很多内容早已了然于胸, 但是即使他们, 也将会发现本章中有很多专属于`Mathematica`的新的知识, 而这些只是是对想写出高效`Mathematica`程序的人必不可少的.

在这一章节中, 例子扮演了帮助理解材料的核心角色. 他们中的很多是用来演示一些基本的概念或微妙的细节的, 因为我坚信, 让人们更好地理解新想法的最好的方式, 就是举一些例子说明. 要完全理解这一章节, 读者最好尝试思考理解每一个例子, 当有注释存在的时候, 读者还需要特别留心. 此外有些例子确实看起来有些"故意为之"的感觉. 这是因为我们主要的目的是为了用最简单的方式演示语言的一些习惯用法.

### 核心高阶函数

#### 介绍
简单地说, `Mathematica`函数式编程(FP)指的是讲函数作用到`Mathematica`通常的表达式上. 一个重要的特例就是当被作用的表达式为列表(也就是说 `Head`为`List`), 在这一章中, 这其实也是我们主要的考察对象. 然而需要指出的是, 大多书关于`表`的函数式操作, 都可以平移到普通的表达式上.

有两个给予 FP 强大的表现力的关键:

1. 函数可以把其他函数当作参数并在运行时以函数为返回值 (在 C 中我们也有函数指针). 返回的函数可以是纯粹意义上的函数, 也可以是带`模式`的函数. 后者在过程式语言中很难找到类比, 因为过程式语言中函数的定义通常在编译时就决定了.

2. `表`的组成元素可以是任意的表达式,可以是原子类型(例如数字, 字符串 或者符号), 也可以是通常的表达式. 特别的, 读者可以考察嵌套(`nested`) 的`表`, 它们可以被用来表示各式各样的数据结构. 这也意味着看似简单的`表`可以包含极其丰富的类型.

我在这里稍微描述一下几个特定的函数式风格的特点, 以让读者能对它有大致的感受. 第一, *副作用* (例如变量的赋值) 在函数式风格中几乎看不见. 第二, 函数式风格中极少出现循环的使用. 当然对于后一点, `Mathematica`明令禁止, 只是我们很快就会看到, 我们有其他更自然的构造方式.


以其他函数作为参数的函数, 我们叫做`高阶函数`. 在概念上, 有两个特别重要的高阶函数, `Map` 和 `Apply`. 在实践上, 这两个函数通常也是被最频繁使用的函数, 但是有一些不那么底层的操作也是非常有用的, 所以 `Mathematica` 也包含了其他的一些简单而有用的高阶函数.

现在让我们来看一看一些最常用的内置的高阶函数吧, 我会用一些例子说明他们的用法. 因为这些函数是如此地基本和有用, 读者仅仅依靠他们就可以作出很多有意义的操作.


### `Map` 的最简单形式
作为两个"最基本"的内置高阶函数, `Map` 也可能是目前为止最常用的一个. 粗略地说, `Map` 就是 FP 版本的循环.

在它的最简单的形式中, `Map` 使用两个参数: 一个单变量函数 (让我们记作 `f` ) 以及一个可以被`f` *map* 的表达式 `expr`. 如果 `expr` 是原子类型,那么它将被直接返回. 如果 `expr` 是一个`表` (或者是一个普通的表达式), 那么 `f` 被作用到它的每个元素上, 返回的结果是一个被作用后元素的表.

#### 简单的例子
一些简单的例子:

~~~
Clear[f];
Map[f, a]
~~~~

$a$

~~~~
Map[f, {a, b, c}]
~~~~
$\\{f[a], f[b], f[c]\\}$


上面的例子中,我们并没有给予 `f` 具体的定义, 让我们作如下定义:

~~~~
f[x_] := x^2
~~~~

现在我们有

~~~~
Map[f, {a, b, c}]
~~~~
$\\{a^2, b^2, c^2\\}$

~~~~
Map[f, a]
~~~~
$a$


#### `Map`是 FP 版本的循环
现在我们看看`Map`如何取代循环: 在"过程式"版本中, 我们有形如下面的代码:

~~~~
Module[{i, len, expr, newexpr},
	For[i = 1; expr = {a, b, c};
		len = Length[expr]; newexpr = Table[0, {len}],
		i <= len, i++, newexpr[[i]] = f[expr[[i]]];
	newexpr]
~~~~
$\\{a^2, b^2, c^2\\}$

请读者注意, 我小心地用 `Module` 包裹我的代码, 以避免产生全局性的副作用.

所以显而易见的, 我们可以看到 `Map` 的以下几点好处:

1. 无需引入辅助变量.
2. 无需事先知道`表`的长度.
3. 代码更加紧凑.
4. 在多数情况下我们的代码会更快 (当然, 这并不是显然的).

实际执行过程中, `表` 的一个副本会被创建, 而所有的操作都只针对副本, 因此 原始的 `表` 的状态并不会改变.


#### `Map` 中使用 `纯函数`
我们重写上一个代码, 来演示如何在 `Map` 中使用 `纯函数`:

~~~
Map[#^2 &, {a, b, c}]
~~~
$\\{a^2, b^2, c^2\\}$

在这个例子中, 我们连函数名都可以省略掉. 此外, 纯函数 (尤其是当和 `Map` 配合使用时) 通常比基于 `模式` 定义的函数更加高效, 因为连模式匹配的过程也省了. 但另一方面, 这也意味着对于无效的输入, 我们很难提供有效的保护措施, 这一点我们在之前的内容中也提到过.

#### 符号表示 和 优先级
和许多操作一样, 对 `Map` 我们有简单的符号表示 - 符号 `/@` (slash-at). 用法遵循 `(function /@ expression)` 这样的形式. 例如:

~~~
(f /@ {a, b, c})
~~~
$\\{a^2, b^2, c^2\\}$

~~~
(#^2& /@ {a, b, c})
~~~
$\\{a^2, b^2, c^2\\}$

然而通常我们需要注意跟符号优先级相关的陷阱. 例如下面的例子: 我们想先把 `f` map 到给定的表上, 然后再对得到的表作平方操作. 我们希望能得到 $\\{a^4, b^4, c^4\\}$, 但实际上:

~~~
#^2& @ f /@ {a, b, c} 
~~~
$\\{f^2[a], f^2[b], f^2[c]\\}$


可以看到, 实际的执行过程是, 符号 `f` 被平方了, 然后整体地被 map 到了表上. 现在:

~~~~
#^2& @ ( f /@ {a, b, c} )
~~~~
$\\{a^4, b^4, c^4\\}$

如果我们老老实实地使用 `Map` 函数名的话, 这一类问题几乎是不会出现的:

~~~
#^2& @ Map[f, {a, b, c}]
~~~
$\\{a^4, b^4, c^4\\}$

此外, 原原本本地使用 `Map` 还有助于提高程序的可读性. 所以我的建议是, 读者还不到对简写符号的烂熟于心时候, 不要轻易去使用他们. 但是不得不承认, `/@` 在实践上确实比 `Map` 方便很多.

#### 结合性
`Map` 操作是*右结合* (right-associative) 的, 这意味着我们可以在下面的例子中省略括号:

~~~
g /@ g /@ {a, b, c}
~~~
$\\{ g[g[a]], g[g[b]], g[g[c]]\\}$

~~~
f /@ f /@ {a, b, c}
~~~
$\\{a^4, b^4, c^4\\}$

#### 更多例子
让我们现在考虑一些有趣的例子.
下面的例子帮助我们创建深度为 $2$ 的表:

~~~~
Map[Range, Range[4]]
~~~~

$\\{ \\{1\\}, \\{ 1, 2 \\}, \\{1, 2, 3\\} , \\{1, 2, 3, 4\\} \\}$

或者等价的

~~~~
Range /@ Range[4]
~~~~

$\\{ \\{1\\}, \\{ 1, 2 \\}, \\{1, 2, 3\\} , \\{1, 2, 3, 4\\} \\}$

下面的例子接收一个表组成的表, 返回一个包含每个内部的表的首元素的表:

~~~
Map[First, { {a, b}, {c, d}, {e, f}, {g, h} }]
~~~
$\\{a, c, e, g\\}$


以及这个例子:

~~~
Map[Subsets, { {a, b, c}, {d, e} }]
~~~
$\\{ \\{\\{\\}, \\{a\\}, \\{b\\}, \\{c\\}, \\{a, b\\}, \\{a, c\\}, \\{b, c\\}, \\{a, b, c\\} \\},
\\{ \\{\\}, \\{d\\}, \\{e\\}, \\{d, e\\} \\} \\}$

读者可以从前面的一系列例子中注意到, 那些需要循环的例子往往是用 `Map` 来实现的. 这本身并没有什么美妙的地方 - 真正美妙的地方在于, 既然我们在 `Map` 不需要变量和赋值, 那么我们也根本不需要担心它们. 比如说, 我们根本就不再需要作数组下标是否越界的检查. 另一个额外的好处是, `Map` 对表的操纵是整体性的, 它如何操纵表内的元素由它的内部实现去考虑, 相反的, 过程式地操纵表, 我们则需要"手动"地依次处理每个元素 - 这无疑将会是比较低效的, 这一点我们在之前就已经指出.

#### 多元函数, 除一个参数外其余所有被固定
让我们考虑另外一种情况: 现在我们想 map 一个多元函数, 此函数除一个参数外其余所有参数都被固定. 例如:

~~~
Clear[f, a];
f[x_, y_] := Sin[x + y];
~~~

我们想在固定 $y$ 的情形下把它 map 到表 $\\{1, 2, 3, 4, 5 \\}$. 也许最好的解决方案是利用内置函数 `Thread`. 但出于举例说明的目的, 我们看看能不能用 `Map` 做到这一点. 我们会在某个时候返回这个问题, 并用 `Thread` 给出解决方案.

一种选择是, 定义一个辅助函数 `g`:

~~~
Clear[g];
g[x_] := f[x, a];
~~~

现在:

~~~
Map[g, Range[5]]
~~~

$\\{ Sin[1+a], Sin[2+a], Sin[3+a], Sin[4+a], Sin[5+a] \\}$

如果我们仅仅只是要解决这个问题, 专门定义一个 `g` 未免太浪费了, 因为我们无非之用了一次而已. 如果我们要多次使用 `g`, 一个潜在的危险是, 我们使用了一个全局的 `a` ( 考虑到 `a` 可能会在不同的地方被修改, 我们的程序将会出现非常隐蔽的错误 ). 这样一来, 使用纯函数应当会是一个更好的方案.

~~~~
Map[f[#, a]&, Range[5]]
~~~~
$\\{ Sin[1+a], Sin[2+a], Sin[3+a], Sin[4+a], Sin[5+a] \\}$

## 编写高效程序: 技巧和应用


## 附录
